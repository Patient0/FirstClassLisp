{"tagline":"A Lisp interpreter written in C# with first class macros and continuations","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"### First Class Lisp\r\n\r\nFirst Class Lisp is a 'toy' Lisp interpreter written in C#.\r\n\r\nIt is a Lisp-1 with the following \"interesting\" features:\r\n\r\n* Pattern matching lambda\r\n* First class macros\r\n* First class continuations\r\n* Properly tail recursive\r\n* Clojure style .Net binding\r\n\r\nI wrote it mainly for fun, and to experiment with the idea of [First Class macros] (http://matt.might.net/articles/metacircular-evaluation-and-first-class-run-time-macros/) and the [amb operator] (http://mihai.bazon.net/blog/amb-in-javascript).\r\n\r\nTo try out all of these features and get some idea of performance, I implemented the 'amb' operator as a first-class macro, and re-implemented Peter Norvig's Sudoku algorithm, but using the 'amb' operator to perform the depth-first search.\r\n\r\nAll of the source code is checked in to GitHub, but if you don't have a .Net development environment and would like to try it out, you can try running 'Lisp.exe' on a Windows machine from the [Dist] (https://github.com/Patient0/FirstClassLisp/tree/master/Dist) directory:\r\n\r\n```\r\nC:\\Dist>Lisp\r\nFCLisp> (run \"Examples\\\\Sudoku.lisp\")\r\nSolving grid1...\r\n((4) (8) (3) (9) (2) (1) (6) (5) (7))\r\n((9) (6) (7) (3) (4) (5) (8) (2) (1))\r\n((2) (5) (1) (8) (7) (6) (4) (9) (3))\r\n((5) (4) (8) (1) (3) (2) (9) (7) (6))\r\n((7) (2) (9) (5) (6) (4) (1) (3) (8))\r\n((1) (3) (6) (7) (9) (8) (2) (4) (5))\r\n((3) (7) (2) (6) (8) (9) (5) (1) (4))\r\n((8) (1) (4) (2) (5) (3) (7) (6) (9))\r\n((6) (9) (5) (4) (1) (7) (3) (8) (2))\r\nSolving grid2...\r\nWith rote deduction we only get to:\r\n((4) (1 6 7 9) (1 2 6 7 9) (1 3 9) (2 3 6 9) (2 6 9) (8) (1 2 3 9) (5))\r\n((2 6 7 8 9) (3) (1 2 5 6 7 8 9) (1 4 5 8 9) (2 4 5 6 9) (2 4 5 6 8 9) (1 2 6 7 9) (1 2 4 9) (1 2 4 6 7 9))\r\n((2 6 8 9) (1 5 6 8 9) (1 2 5 6 8 9) (7) (2 3 4 5 6 9) (2 4 5 6 8 9) (1 2 3 6 9) (1 2 3 4 9) (1 2 3 4 6 9))\r\n((3 7 8 9) (2) (1 5 7 8 9) (3 4 5 9) (3 4 5 7 9) (4 5 7 9) (1 3 5 7 9) (6) (1 3 7 8 9))\r\n((3 6 7 9) (1 5 6 7 9) (1 5 6 7 9) (3 5 9) (8) (2 5 6 7 9) (4) (1 2 3 5 9) (1 2 3 7 9))\r\n((3 6 7 8 9) (4) (5 6 7 8 9) (3 5 9) (1) (2 5 6 7 9) (2 3 5 7 9) (2 3 5 8 9) (2 3 7 8 9))\r\n((2 8 9) (8 9) (2 8 9) (6) (4 5 9) (3) (1 2 5 9) (7) (1 2 4 8 9))\r\n((5) (6 7 8 9) (3) (2) (4 7 9) (1) (6 9) (4 8 9) (4 6 8 9))\r\n((1) (6 7 8 9) (4) (5 8 9) (5 7 9) (5 7 8 9) (2 3 5 6 9) (2 3 5 8 9) (2 3 6 8 9))\r\nSolving using non-deterministic search...\r\nAssiging 8 to 55\r\nAssiging 2 to 54\r\nAssiging 4 to 58\r\nAssiging 6 to 64\r\nAssiging 1 to 1\r\nAssiging 3 to 3\r\nAssiging 2 to 7\r\nAssiging 6 to 4\r\nAssiging 9 to 4\r\nAssiging 9 to 7\r\nAssiging 2 to 4\r\nAssiging 6 to 4\r\nAssiging 9 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 9 to 1\r\nAssiging 1 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 3 to 3\r\nAssiging 2 to 4\r\nAssiging 6 to 4\r\nAssiging 7 to 64\r\nAssiging 1 to 1\r\nAssiging 3 to 3\r\nSolution:\r\n((4) (1) (7) (3) (6) (9) (8) (2) (5))\r\n((6) (3) (2) (1) (5) (8) (9) (4) (7))\r\n((9) (5) (8) (7) (2) (4) (3) (1) (6))\r\n((8) (2) (5) (4) (3) (7) (1) (6) (9))\r\n((7) (9) (1) (5) (8) (6) (4) (3) (2))\r\n((3) (4) (6) (9) (1) (2) (7) (5) (8))\r\n((2) (8) (9) (6) (4) (3) (5) (7) (1))\r\n((5) (7) (3) (2) (9) (1) (6) (8) (4))\r\n((1) (6) (4) (8) (7) (5) (2) (9) (3))\r\n-> ()\r\nSteps: 11141444 Expansions: 219 Lookups: 1400200 Elapsed: 00:00:04.3050062\r\nFCLisp>\r\n```\r\n\r\n### Pattern-matching lambda\r\n\r\nStandard scheme syntax allows only the following three forms for arguments:\r\n\r\n\r\n```\r\n(lambda x ...) ' list args\r\n(lambda (a b) ...) ' positional args\r\n(lambda (a b . c) ...) ' some combination\r\n```\r\n\r\nIn First Class Lisp, the format is:\r\n\r\n```\r\n(lambda pattern1 body1\r\n        pattern2 body2\r\n        ...)\r\n```\r\n\r\nAs well as the usual variations of argument patterns, you can also arbitarily nest them and include constant expressions and quoted symbols. For example, here are the definitions of some of the standard scheme functions in First Class Lisp:\r\n\r\n```\r\n(define car (lambda ((a . b)) a))\r\n(define cdr (lambda ((c . d)) d))\r\n(define pair? (lambda ((_ . _)) #t _ #f))\r\n(define nil? (lambda (()) #t _ #f))\r\n```\r\n\r\nI did this because it was actually easier - once you've written the code to match the standard argument patterns, it's a simple generalization to make it match arbitrarily deep argument specifications.\r\nThe only disadvantage to adding pattern matching this way is that 'lambda' no longer has an implicit 'begin'. \r\n\r\nI also added support for matching against literals including symbol literals (by quoting them). This was also not too hard, and greatly simplified the implementation of the quasiquote macro:\r\n\r\n```\r\n(define expand-quasiquote\r\n    (lambda\r\n        (('unquote e))\r\n            e\r\n        ((('unquote-splicing x) . y))\r\n            (list append x (expand-quasiquote y))\r\n        ((x . y))\r\n            (list cons (expand-quasiquote x) (expand-quasiquote y))\r\n        x\r\n            (cons quote x)))\r\n(define quasiquote\r\n    (macro expand-quasiquote))\r\n```\r\n\r\nI was even able to implement the core form `if` as a macro:\r\n\r\n```\r\n(define if (macro\r\n    (lambda (condition true-case false-case)\r\n            ; Base case. Anything not false is considered 'true'\r\n                `((,lambda (#f) ,false-case\r\n                            _   ,true-case) ,condition))))\r\n```\r\n\r\n### Why first class macros?\r\n\r\nI wanted to have macros in my Lisp interpreter - but I didn't want to implement fully-fledged Scheme hygienic macros (\"syntax-rules\"), which I still find difficult to understand, let alone implement!\r\n\r\nFirst class macros provide an easy but elegant way to solve the [hygiene] (http://en.wikipedia.org/wiki/Hygienic_macro) problem.\r\n\r\nIn a conventional lisp you might define, say, an [arc](http://ycombinator.com/arc/tut.txt) style \"let\" macro as follows:\r\n\r\n```\r\n(define-macro let (var value body)\r\n    `(lambda (,var) ,body) ,value))\r\n```\r\n\r\nThis would expand:\r\n\r\n```\r\n(let x 5 (* x x))\r\n```\r\ninto\r\n```\r\n((lambda (x) (* x x) 5)\r\n```\r\n\r\nThis can cause problems though in that we are relying on `lambda` not having some alternative meaning in the scope in which the let statement was expanded\r\n```\r\n(define (energy lambda)\r\n (with (c speed-of-light\r\n        h plancks-constant)\r\n  (/ (* c h) lambda)))\r\n```\r\n\r\nI got the above example from [Matt Might's page on first class macros](http://matt.might.net/articles/metacircular-evaluation-and-first-class-run-time-macros/) which is a very good read (as are most articles on his page).\r\nIn fact, Matt's page was my original inspiration for implementing macros this way.\r\n\r\nIn First Class Lisp, the 'let' macro is very similar to the one I described earlier, but with one small change:\r\n```\r\n(define-macro let (var value body)\r\n    `(,lambda (,var) ,body) ,value))\r\n```\r\n\r\nSee the \",\" before lambda? This is how we solve the hygiene problem: we are unquoting 'lambda' to evaluate it in the environment of the macro expansion rather than the 'calling' context.\r\n\r\nThis is made possible by the fact that *all* special forms in FirstClass Lisp are actually just [fexprs](http://en.wikipedia.org/wiki/Fexpr) defined in the current lexical environment.\r\nOur macros are just special cases of these f-expressions (except macros do not have access to the environment itself to perform their expansion).\r\n\r\nBecause all of these objects are mapped to names in the current environment, they can be passed and returned from functions like ordinary objects:\r\n\r\n```\r\n(with (identity (lambda (x) x))\r\n           ((identity let) x 3\r\n                (* x x)))\r\n```\r\n\r\nMy Lisp interpreter doesn't currently let you define your own f-expressions - only your own macros. Also, 'apply', in my Lisp interpreter is a normal function - it doesn't work with macros or f-expressions.\r\nOne could enhance it to support this, but this would mean that 'apply' itself could no longer be a function... I wasn't sure if I wanted to go all the way in this direction.\r\n\r\nHowever, for an example of someone who *has* gone all the way down the rabbit-hole in this direction, I recommend checking out this article about [Kernel](http://mainisusuallyafunction.blogspot.co.uk/2012/04/scheme-without-special-forms.html).\r\n\r\nOne last thing: because of the more flexible argument syntax for 'lambda', 'let' automatically supports 'destructuring'. For example:\r\n\r\n```\r\n(let (first . rest) (compute-some-list)\r\n     (do-something-with first rest))\r\n```\r\n\r\n### First class continuations\r\n\r\nThe simplest way to implement an interpreter is to recursively visit the expression-tree, collecting up the terms.\r\n\r\nFor example, to implement some sort of arithmetic expression evaluator, you'd usually do something like this:\r\n\r\n```\r\ninterface IExpression\r\n{\r\n    double evaluate(Environment e);\r\n}\r\n\r\nclass Multiply : IExpression\r\n{\r\n    IExpression left;\r\n    IExpression right;\r\n    public double evaluate(Environment e)\r\n    {\r\n        return left.evaluate(e) * right.evaluate(e);\r\n    }\r\n}\r\n```\r\n\r\nIn fact, if you look at the GitHub history, you'll see that I started First Class Lisp in this exact way. It's very simple because you are using the implicit runtime stack to keep track of 'where you are'.\r\n\r\nAlthough it's simple, there are two disadvantages to the implicit approach:\r\n\r\n1. Properly 'tail recursive' programs in Lisp ideally should be able to loop in constant space. The implicit approach, however, will encounter stack overflow errors.\r\n2. You can't implement proper continuations which are implemented as pure 'first class' objects.\r\n\r\nTo resolve these issues, my approach was to use two \"stacks\" to keep track of the current interpreter state:\r\n\r\n1. A stack of 'tasks' that still need to be performed\r\n2. A stack of results which have been calculated\r\n\r\nWe start by pushing the task 'evaluate the expression' on the stack. We then repeatedly pull the top\r\n'task' off the stack and execute it, until there are no more tasks. Once a 'task' has been fully evaluated, the result should be on the result stack. The trick is, the evaluation of a task can trigger *further* tasks to be evaluated,\r\nand intermediate results can be pushed onto the result stack in the mean time.\r\n\r\nThe approach is essentially the same as the [Shunting Yard Algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm).\r\n\r\nTo implement first-class continuations efficiently, only one other thing was required, which was to make the entire structure of both stacks **immutable**:\r\n\r\n```\r\n    public interface Continuation\r\n    {\r\n        Continuation PushTask(Task task);\r\n        Continuation PopTask();\r\n        Continuation PushResult(Datum d);\r\n        Continuation PopResult();\r\n        // The current task\r\n        Task Task { get; }\r\n        // The current result\r\n        Datum Result { get; }\r\n    }\r\n```\r\n\r\nThis made it safe to pass the structure around, keep it as a variable and so on.\r\nA `Task` is simply an object that knows how to get from one Continuation to the next. Here's the main loop of the interpreter:\r\n\r\n```\r\n        private static Datum Evaluate(Continuation c)\r\n        {\r\n            while (c.Task != null)\r\n            {\r\n                try\r\n                {\r\n                    c = c.Task.Perform(c.PopTask());\r\n                    c.Statistics.Steps++;\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    c = c.ErrorHandler(c, ex);\r\n                }\r\n            }\r\n            return c.Result;\r\n        }\r\n```\r\n\r\n\r\n### .Net method bindings and REPL\r\n\r\nWith the help of my friend [Tim] (http://www.partario.com/blog/) we've also added some basic .Net method bindings. Here are some examples that show how it is used inside\r\nthe REPL:\r\n\r\n\r\n```\r\nFCLisp> (System.String/Format \"{0} * {1} is {2}\" 4 5 (* 4 5))\r\n-> 4 * 5 is 20\r\nSteps: 507 Expansions: 2 Lookups: 46 Elapsed: 00:00:00.0007447\r\nFCLisp> (.Equals \"hello\" \"hello\")\r\n-> True\r\nSteps: 318 Expansions: 1 Lookups: 15 Elapsed: 00:00:00.0004844\r\nFCLisp> (map .ToString '(1 2 3))\r\n-> (\"1\" \"2\" \"3\")\r\nSteps: 1141 Expansions: 1 Lookups: 175 Elapsed: 00:00:00.0012821\r\nFCLisp>\r\n```\r\n\r\nAfter each statement, the REPL prints out:\r\n* Steps: The number of Tasks that were performed\r\n* Expansions: The number of macro expansions that were performed (excluding cached expansions - see below)\r\n* Elapsed: How long it took\r\n\r\nThe Clojure/style .NET syntax was achieved by augmenting the way that the reader reads in symbols that contain a \".\" or a \"/\".\r\n\"System.String/Format\" is read in by the reader as \"(slash (dot System String))\".\r\n\".Equals\" is read in by the reader as \"(dot () Equals)\".\r\n\"dot\" and \"slash\" are in turn defined as macros which use reflection to invoke the corresponding .Net method:\r\n\r\n```\r\n(define-macro dot args\r\n    (match args\r\n           (() method)\r\n                `(,make-instance-method ,(symbol->string method))\r\n           name-parts\r\n                `(,get-type ,@(mapcar symbol->string name-parts))))\r\n\r\n; System.Console/WriteLine =>\r\n; (slash (dot System Console) WriteLine) =>\r\n; (get-static-method (get-type \"System\" \"Console\") \"WriteLine\")\r\n(define-macro slash (type method)\r\n           `(,get-static-method ,type ,(symbol->string method)))\r\n```\r\n\r\n### REPL\r\n\r\nThe First Class Lisp \"REPL\" also includes an extremely primitive debugger. The REPL and the debugger are both implemented in Lisp itself.\r\nThe \"main\" method of Lisp.exe simply creates a standard environment and evaluates \"REPL.lisp\".\r\n\r\n\r\n```\r\nFCLisp> (map (lambda (x) z) '(1 2 3))\r\nERROR: Undefined symbol 'z'\r\n(debug) to enter debug repl\r\nFCLisp> (debug)\r\ndebug> (trace)\r\nERROR: Undefined symbol 'z'\r\nTasks:\r\n        Evaluate '(loop)' (Lisp.REPL.lisp:86)\r\n        Discard result\r\n        RestoreErrorHandler\r\n        Invoke '(lambda (result) (,begin ((,macro (lambda (() body) body ((var expr . bindings) . body) `(,let ,var ,expr (,with* ,bindings (,begin ,@body)))))\r\n() (,begin (,begin (,begin (display result) (log-steps ((dot () get_Elapsed) stop-watch))))))))' with 1 args\r\n        Invoke '(lambda (l) (,begin (define reverse-tail (lambda (so-far ()) so-far (so-far (x . y)) (reverse-tail (cons x so-far) y))) (reverse-tail '() l)))'\r\nwith 1 args\r\n        Invoke '(lambda (f so-far (() . rest)) so-far (f so-far ll) (map-tail f (cons (apply f (mapcar car ll)) so-far) (mapcar cdr ll)))' with 3 args\r\n        Evaluate '(mapcar cdr ll)' (LispEngine.Bootstrap.Library.lisp:47)\r\n        Invoke ',cons' with 2 args\r\n        Evaluate 'so-far' ()\r\n        Evaluate 'z' ()\r\nResults:\r\n        (lambda (x) z)\r\n-> ()\r\nSteps: 3527 Expansions: 10 Lookups: 457 Elapsed: 00:00:00.0093698\r\ndebug> x ; Evaluate 'x' in the frame where the error occurred\r\n-> 1\r\nSteps: 270 Expansions: 0 Lookups: 15 Elapsed: 00:00:00.0003116\r\ndebug> (exit) ; exit debug REPL back into main REPL\r\n-> ()\r\nSteps: 284 Expansions: 0 Lookups: 18 Elapsed: 00:00:29.7198458\r\n```\r\n\r\nAs you will also notice, the debugger is so primitive that it's essentially useless at this stage. You're probably better off sticking in print statements in the code if your\r\nFirst Class Lisp program isn't working.\r\n\r\n### Sudoku solver\r\n\r\nWhat use are first class continuations?\r\n\r\nOne example which I always thought was really cool is that they allow you to implement the [amb operator] (http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/).\r\n\r\nVarious web sites (and [SICP] (http://mitpress.mit.edu/sicp/)) give some example programs that use the amb operator (sentence parsing, solving the N-queens problem) but they all seemed a bit \"trivial\" and/or useless.\r\nInstead, I've re-implemented [Peter Norvig's Sudoku algorithm] (http://norvig.com/sudoku.html) in First Class Lisp, but using the amb operator to implement the depth-first search.\r\n\r\nThe basic strategy of a Sudoku solver is to apply all of your \"deductive\" reasoning rules (\"if this square has a 6 then all these other squares can no longer have a 6\") up until the point at which there are no more rules to apply.\r\nAt this point either you've solved the puzzle, or there are still squares which could have multiple digits.\r\n\r\nWhereas Peter's program **explicitly** tries all of the possibilities, in First Class Lisp I use the amb operator to pick \"the right choice\":\r\n\r\n```\r\n    (define (solve grid)\r\n        (if (solved? grid)\r\n            grid\r\n            (with* ((s . digits) (square-to-try grid)\r\n                    d (amb digits))\r\n                   (write-line \"Assiging {0} to {1}\" d s)\r\n                   (solve (assign! (copy-grid grid) s d)))))\r\n```\r\n\r\nThe above function translates to:\r\n\r\n\"If the grid is solved, return the grid.\r\nOtherwise, find a square 's' with more than one possible digit and\r\n*let d be the correct choice amongst the available digits*.\r\nAssign 'd' to square 's' and solve the other squares\".\r\n\r\nSo assuming that we could know in advance what the correct digit is for each square, this is a linear algorithm!\r\n\r\nOf course, we can't *really* know the correct square in advance. What actually happens is that the \"amb\" operator saves the current continuation and returns one of the digits. If it turns out that it was the \"wrong\" choice (because we got an inconsistency),\r\nwe call \"(amb)\" which indicates that we need to go back and try something else. (amb) restores the previous continuation and resumes from the next possible choice.\r\n\r\nHere is what you see what you run \"Sudoku.lisp\" from the Examples directory:\r\n\r\n```\r\nFCLisp> (run \"..\\\\..\\\\Examples\\\\Sudoku.lisp\")\r\nSolving grid1...\r\n((4) (8) (3) (9) (2) (1) (6) (5) (7))\r\n((9) (6) (7) (3) (4) (5) (8) (2) (1))\r\n((2) (5) (1) (8) (7) (6) (4) (9) (3))\r\n((5) (4) (8) (1) (3) (2) (9) (7) (6))\r\n((7) (2) (9) (5) (6) (4) (1) (3) (8))\r\n((1) (3) (6) (7) (9) (8) (2) (4) (5))\r\n((3) (7) (2) (6) (8) (9) (5) (1) (4))\r\n((8) (1) (4) (2) (5) (3) (7) (6) (9))\r\n((6) (9) (5) (4) (1) (7) (3) (8) (2))\r\nSolving grid2...\r\nWith rote deduction we only get to:\r\n((4) (1 6 7 9) (1 2 6 7 9) (1 3 9) (2 3 6 9) (2 6 9) (8) (1 2 3 9) (5))\r\n((2 6 7 8 9) (3) (1 2 5 6 7 8 9) (1 4 5 8 9) (2 4 5 6 9) (2 4 5 6 8 9) (1 2 6 7 9) (1 2 4 9) (1 2 4 6 7 9))\r\n((2 6 8 9) (1 5 6 8 9) (1 2 5 6 8 9) (7) (2 3 4 5 6 9) (2 4 5 6 8 9) (1 2 3 6 9) (1 2 3 4 9) (1 2 3 4 6 9))\r\n((3 7 8 9) (2) (1 5 7 8 9) (3 4 5 9) (3 4 5 7 9) (4 5 7 9) (1 3 5 7 9) (6) (1 3 7 8 9))\r\n((3 6 7 9) (1 5 6 7 9) (1 5 6 7 9) (3 5 9) (8) (2 5 6 7 9) (4) (1 2 3 5 9) (1 2 3 7 9))\r\n((3 6 7 8 9) (4) (5 6 7 8 9) (3 5 9) (1) (2 5 6 7 9) (2 3 5 7 9) (2 3 5 8 9) (2 3 7 8 9))\r\n((2 8 9) (8 9) (2 8 9) (6) (4 5 9) (3) (1 2 5 9) (7) (1 2 4 8 9))\r\n((5) (6 7 8 9) (3) (2) (4 7 9) (1) (6 9) (4 8 9) (4 6 8 9))\r\n((1) (6 7 8 9) (4) (5 8 9) (5 7 9) (5 7 8 9) (2 3 5 6 9) (2 3 5 8 9) (2 3 6 8 9))\r\nSolving using non-deterministic search...\r\nAssiging 8 to 55\r\nAssiging 2 to 54\r\nAssiging 4 to 58\r\nAssiging 6 to 64\r\nAssiging 1 to 1\r\nAssiging 3 to 3\r\nAssiging 2 to 7\r\nAssiging 6 to 4\r\nAssiging 9 to 4\r\nAssiging 9 to 7\r\nAssiging 2 to 4\r\nAssiging 6 to 4\r\nAssiging 9 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 9 to 1\r\nAssiging 1 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 3 to 3\r\nAssiging 2 to 4\r\nAssiging 6 to 4\r\nAssiging 7 to 64\r\nAssiging 1 to 1\r\nAssiging 3 to 3\r\nSolution:\r\n((4) (1) (7) (3) (6) (9) (8) (2) (5))\r\n((6) (3) (2) (1) (5) (8) (9) (4) (7))\r\n((9) (5) (8) (7) (2) (4) (3) (1) (6))\r\n((8) (2) (5) (4) (3) (7) (1) (6) (9))\r\n((7) (9) (1) (5) (8) (6) (4) (3) (2))\r\n((3) (4) (6) (9) (1) (2) (7) (5) (8))\r\n((2) (8) (9) (6) (4) (3) (5) (7) (1))\r\n((5) (7) (3) (2) (9) (1) (6) (8) (4))\r\n((1) (6) (4) (8) (7) (5) (2) (9) (3))\r\n-> ()\r\nSteps: 11141444 Expansions: 219 Lookups: 1400200 Elapsed: 00:00:04.2279425\r\nFCLisp>\r\n```\r\n\r\nTo understand the way that \"amb\" works, you can also just try typing in \"(amb)\" at the command prompt after it has successfully solved a puzzle, to see if there are any *other* solutions. If the Sudoku puzzle that was supplied is not unique,\r\nyou'll get all of the solutions by repeatedly typing `(amb)`.\r\n\r\n```\r\nFCLisp> (amb)\r\nAssiging 9 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 9 to 1\r\nAssiging 1 to 3\r\nAssiging 2 to 5\r\nAssiging 6 to 5\r\nAssiging 3 to 3\r\n... etc.\r\nAssiging 3 to 3\r\nAssiging 9 to 55\r\nAssiging 2 to 54\r\nAssiging 8 to 54\r\nERROR: No solution\r\n(debug) to enter debug repl\r\n```\r\n\r\nPeter's solution used dictionaries and strings, which work very well natively in Python. Because I didn't have a dictionary class as a builtin and was going to have to write some sort of data structure myself anyway,\r\nI decided to add \"vectors\" (the Scheme/Lisp name for an array) and use those instead.\r\n\r\nI used a vector of integers to represent a partially solved Sudoku board.\r\n\r\nEach square corresponds to an index into the vector using the formula `9 * row + column` i.e.\r\n\r\n```\r\n0  1  2  |3  4  5  |6  7  8  |\r\n9  10 11 |12 13 14 |15 16 17 |\r\n18 19 20 |21 22 23 |24 25 26 |\r\n---------+---------+---------+\r\n27 28 29 |30 31 32 |33 34 35 |\r\n... and so on.\r\n```\r\n\r\nInside each square a number between 0 and 511 inclusive represents which digits are still possible (one bit for each digit).\r\n\r\n### Performance\r\n\r\nMy first attempt at the Sudoku solver, once it finally worked, was agonizingly slow. It took about 60 seconds, and 140 million steps, to run \"Sudoku.lisp\", which merely loads and solves \"grid1\" and \"grid2\" in Peter Norvig's article.\r\n\r\nI was able to get this time to under 5 seconds, by use of the following optimizations:\r\n\r\n#### Macro expansion caching\r\n\r\nWhenever a macro is expanded, the expansion is cached inside the Datum that was expanded. The next time the interpreter is asked to expand the same macro against the same input code instance, it re-uses the previous expansion.\r\nThis eliminated repeated macro expansions in all cases where macros are used in a manner that would also work for 'compile time' macros, which turned out to be almost all of the time.\r\n\r\nIn the case of a macro being used as a true \"first class\" macro - e.g. different macros being expanded against the same code instance because the macro was passed as an argument to a function,\r\nit will simply degrade gracefully but correctly.\r\n\r\n#### Symbol lookup caching\r\n\r\nOnce the macro expansions are out of the way, the next most expensive step is looking up symbols in the environment.\r\n\r\nAt this stage, I have only managed to adopt the following fairly simple and not quite correct optimization: Whenever we lookup a symbol in an environment, we cache the location of its bound value inside the Symbol datum itself.\r\nIf we are asked to resolve the same symbol instance against an environment and the symbol was previously resolved against the same environment or one of its parent environments, we skip to that same location.\r\n\r\nThis optimization isn't quite robust - but I suspect will only break in \"pathological\" situations in which a macro expands a source tree into a graph in which different nodes in different lexical scopes refer to the same symbol.\r\nThe (commented out) unit test 'symbol-lookup-cache' in EvaluatorTests.lisp documents the way in which it can fail.\r\n\r\nI had hoped that it would be possible to pre-process the expression-tree after macro expansion, replacing each symbol reference with its 'lexical location' along the lines of [this excellent paper] (http://www.cs.unm.edu/~williams/cs491/three-imp.pdf).\r\n\r\nHowever, determining the true lexical location of each symbol reference is much more complicated because it depends on the nature of the \"first\" form that expands each element. For example, consider the following\r\n\r\n```\r\n((lambda (x)\r\n    (x)) 5)\r\n```\r\n\r\nIn a conventional Lisp, we can automatically replace the `x` in the body with some sort of lexical marker - and even replace the entire expression with the constant `5` - because the effect of the `lambda` is essentially hard coded.\r\n\r\nWe know the effect that `lambda` will have on its environment without actually having to evaluate it.\r\n\r\nIn First Class Lisp, the meaning of 'lambda' itself depends on the surrounding lexical environment, which may or may not impact which lexical scope that the symbol 'x' is in - this makes it difficult (but probably not impossible?) to optimize these lookups.\r\n\r\n### Conclusion and next steps\r\n\r\nI have to say I've really enjoyed working on this project! I particularly liked the experience of working with macros. Being able to write a macro any time I found myself writing some boiler plate code has been a trully addictive experience!\r\n\r\nI've reached the limits of most of the things that I know how to do easily (i.e. without spending days thinking about it!) - so I'm turning it over to you, open source community, to do with it as you will!\r\n\r\nThe following are areas in which First Class Lisp could be improved:\r\n\r\n#### Performance\r\n\r\nPerformance is \"acceptable\" - however it would be great if it was possible to implement some sort of incremental compiler while still preserving first class semantics.\r\nThe first class semantics makes this difficult - but I'm not sure that it's actually impossible.\r\n\r\nThe benchmark: My \"optimized\" version of the Sudoku solver runs in about 4.5 seconds. In contrast, Peter Norvig's solver solves both puzzles in well under 0.03 seconds!\r\n\r\n#### Debugging\r\n\r\nThe 'shunting yard' algorithm made an easy and flexible machine for evaluating the expressions - but gives a very incomprehensible 'trace' when debugging things, and made it quite hard to\r\nimplement any standard debugging features like \"resume from the next statement\". The problem is that the stack of \"Tasks\" is too low level - \"stepping\" feels like stepping through assembly language\r\nrather than source code.\r\n\r\nBy choosing a different internal representation of the interpreter state I think it would be possible to improve the debugger so that it's something that you would actually want to use.\r\n\r\n#### Pull requests welcome!\r\n\r\nSo, with this all of this in mind: Feel free to make a fork of this repository to add your own enhancements or use this as the basis for some other cool project.\r\n\r\nI'd particularly welcome any feedback or suggestions on how to improve it - and a pull request would be even more appreciated!\r\n\r\n\r\n","name":"First Class Lisp","google":""}